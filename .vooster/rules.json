{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구 사항 문서 (PRD)\n\n## 1. 요약\nAI 기능이 내장된 개인 기술 블로그 플랫폼 \"Dom vlog\"를 개발한다. 1차적으로 개발자 본인이 개인 블로그로 사용하며, AI가 자동으로 가독성을 향상시키고 SEO 최적화를 수행하며, 적절한 카테고리를 추천한다. 안정화 후 멀티 사용자 플랫폼으로 확장한다.\n\n## 2. 문제 정의 \n- 개인 기술 블로그 운영 시 글 편집, SEO, 카테고리 관리가 번거롭다.\n- 개발자는 콘텐츠 품질보다는 기술 공유에 집중하고 싶어 함.\n- 기존 플랫폼(Notion, Velog)은 AI 기반 자동 편집·SEO·추천 기능이 부족함.\n- 개인 도메인으로 독립적인 블로그 운영을 원하지만 기술적 복잡도가 높음.\n\n## 3. 목표 및 지표\n\n### Phase 1 (개인 사용)\n- 1차 목표: AI로 글 가독성·SEO 점수 ≥ 80점(SEO 툴 기준) 자동 달성\n- 2차 목표: 추천 카테고리 정확도 ≥ 85%\n- 성공지표\n  • 개인 글 준비 시간 50% 단축\n  • 게시글 평균 유입 30% 증가(SEO)\n  • 플랫폼 안정성 99.5% 이상\n\n### Phase 2 (플랫폼 확장)\n- 월 활성 사용자 100명 달성\n- 사용자당 평균 월 게시글 4개 이상\n- 플랫폼 가입 전환율 20% 이상\n\n## 4. 대상 사용자\n\n### Phase 1: 단일 사용자 (개발자 본인)\n- 웹/블록체인/암호학 분야 개발자\n- 필요: 빠른 개인 글 게시, 자동 스타일링, 개인 브랜딩\n\n### Phase 2: 확장 사용자\n- 기술 개발자 커뮤니티 (20-40대)\n- 개인 기술 블로그 운영 희망자\n- 필요: 간편한 블로그 생성, AI 지원, 트래픽 확보\n\n### 이해관계자\n- 기술 커뮤니티, 리크루터, 광고주(수익화 단계)\n\n## 5. 사용자 스토리\n\n### Phase 1 (개인 사용)\n- \"개발자로서 내 개인 블로그에 글을 올릴 때 AI가 코드 블록과 제목을 자동 정돈해 읽기 쉽도록 하고 싶다.\"\n- \"개인 블로그 SEO를 위해 키워드·메타태그를 AI가 자동으로 채워줘 검색 노출을 높이고 싶다.\"\n- \"다양한 기술 주제 글을 작성할 때 적절한 카테고리를 추천받아 개인 블로그를 체계적으로 관리하고 싶다.\"\n\n### Phase 2 (플랫폼 확장)\n- \"다른 개발자들도 나와 같은 경험을 할 수 있도록 플랫폼을 제공하고 싶다.\"\n- \"새로운 사용자로서 복잡한 설정 없이 바로 기술 블로그를 시작하고 싶다.\"\n\n## 6. 기능 요구 사항\n\n### Phase 1 핵심 기능 (개인 사용)\n1. **개인 블로그 기본 기능**\n   - 단일 사용자 인증 (개발자 본인)\n   - 글 작성/수정/삭제/게시\n   - 개인 프로필 및 블로그 설정\n\n2. **AI 문서 스타일 업그레이드**\n   - 입력: Markdown/HTML 원본 글\n   - 처리: AI가 제목 구조, 코드 하이라이트, 표·목차 자동 생성\n   - 완성 기준: 가독성 평가 점수 ≥ 80, 2초 이내 미리보기 제공\n\n3. **SEO 향상**\n   - AI가 키워드 추출, 메타디스크립션, OG 태그, URL 슬러그 추천\n   - SEO 점수(3rd party API) ≥ 80 자동 검증\n\n4. **AI 카테고리 추천**\n   - 주제 모델링으로 다중 카테고리 후보 제시(상위 3개, 신뢰도 표시)\n   - 선택 후 자동 태깅\n\n### Phase 2 확장 기능 (멀티 사용자)\n1. **멀티 사용자 지원**\n   - 사용자 회원가입/로그인 시스템\n   - 개별 사용자 블로그 공간 제공\n   - 사용자별 도메인/서브도메인 지원\n\n2. **사용자 관리 시스템**\n   - 사용자 대시보드: 조회수·SEO 점수 시각화\n   - 사용자별 설정 및 테마 커스터마이징\n   - 사용자 간 블로그 방문 및 소통 기능\n\n3. **플랫폼 운영 기능**\n   - 관리자 패널 (사용자 관리, 시스템 모니터링)\n   - 사용 통계 및 분석\n   - 수익화 모듈 준비 (구글 애드센스, 구독 모델)\n\n## 7. 비기능 요구 사항\n\n### Phase 1\n- 성능: 개인 사용 기준 글 편집→배포 ≤ 3초\n- 보안: 기본 인증, 데이터 백업\n- 사용성: 개인 맞춤 인터페이스, 다크모드\n- 안정성: 99.5% 가동률\n\n### Phase 2  \n- 성능: 동시 요청 500RPS, 글 편집→배포 ≤ 5초\n- 보안: Supabase Auth(OAuth, 2FA), 데이터 암호화 at-rest/in-transit\n- 사용성: WCAG 2.1 AA, 반응형 디자인\n- 확장성: 멀티테넌트 DB, 서버리스 함수\n- 호환: 최신 Chrome, Firefox, Safari, Edge\n\n## 8. 기술 고려\n- **프론트엔드**: Next.js 15(App Router, ISR)\n- **백엔드**: Supabase(PostgreSQL, Edge Functions)  \n- **AI 서비스**: Gemini-2.5-flash-lite, LangChain 파이프라인\n- **SEO 계산**: Lighthouse CI, Ahrefs API 연동\n- **인프라**: Vercel(프론트), Supabase(hosted DB), Cloudflare CDN\n- **데이터 설계**:\n  - Phase 1: 단일 사용자 스키마 (posts, categories, seo_scores)\n  - Phase 2: 멀티 사용자 스키마 (users, user_blogs, posts, categories)\n- **통합**: GitHub SSO, Google Analytics, AdSense(Phase 2)\n\n## 9. KPI\n\n### Phase 1 (개인 사용)\n- 기능: AI 스타일링 만족도 90% 이상 (개인 평가)\n- 기술: 평균 응답시간 100ms 이하, AI 호출 실패율 <1%\n- 비즈니스: 개인 블로그 트래픽 월 30% 증가\n\n### Phase 2 (플랫폼 확장)\n- 기능: AI 스타일링 적용율 85% 이상\n- 비즈니스: 신규 가입 전환율 20% 이상, 월 활성 사용자 100명\n- 기술: 평균 TTFB 150ms 이하, 시스템 가동률 99.9%\n\n## 10. 일정 및 마일스톤\n\n### Phase 1: 개인 MVP (M0-M3)\n- **M0-M1**: 기본 개인 블로그 기능 (글 작성, 게시, 기본 UI)\n- **M1-M2**: AI 스타일 업그레이드 기능 구현\n- **M2-M3**: SEO 최적화 및 카테고리 추천 기능\n\n### Phase 2: 플랫폼 확장 (M4-M7)  \n- **M4-M5**: 멀티 사용자 시스템 개발\n- **M5-M6**: 사용자 대시보드 및 관리 기능\n- **M6-M7**: 수익화 모듈 및 고급 기능\n\n### Phase 3: 확장 및 최적화 (M8+)\n- 모바일 앱, 고급 협업 기능, 글로벌 확장\n\n## 11. 위험 및 대응\n\n### Phase 1 위험\n- **개인 사용 중 기능 결함** → 신속한 자체 수정, 백업 시스템\n- **AI 비용 초과** → 개인 사용량 모니터링, 캐싱 전략\n\n### Phase 2 위험  \n- **사용자 확보 실패** → 개발 커뮤니티 홍보, 무료 체험 제공\n- **AI 출력 부정확** → 사용자 피드백 시스템, 수동 검토 옵션\n- **서버 비용 급증** → 사용량 기반 요금제, 효율적인 리소스 관리\n- **경쟁 플랫폼 등장** → 차별화된 AI 기능 지속 개발\n\n## 12. 향후 계획\n- **Phase 1 완료 후**: 개인 사용 데이터 분석하여 개선점 도출\n- **Phase 2 성공 시**: \n  - AI 음성·영상 포스트 변환\n  - 플러그인 마켓플레이스(테마·위젯)  \n  - 온프레미스 배포 옵션\n  - 개발자 커뮤니티 기능 강화\n- **장기 비전**: 개발자 중심의 AI 지원 콘텐츠 플랫폼 리더",
      "writedAt": "2025-06-23T16:25:10.419Z"
    },
    {
      "type": "architecture",
      "content": "```markdown\n# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  “Dom vlog”는 AI가 자동으로 글 가독성·SEO·카테고리를 최적화해 주는 개인 → 멀티사용자 기술 블로그 플랫폼이다. 초기(Phase 1)는 단일 사용자를 위한 Monorepo-Monolith 구조로 빠른 배포와 비용 최소화를 달성하고, 이후(Phase 2)는 멀티테넌트 확장을 위해 모듈 단위 수평 확장 전략을 적용한다.\n\n- **핵심 기술 스택**  \n  • Frontend: Next.js 15(App Router) + Shadcn UI + Tailwind CSS + Lucide Icons  \n  • Backend/API: Next.js API Route(tRPC) + Supabase(PostgreSQL) + Prisma  \n  • AI: Vercel AI SDK + LangChain + Gemini-2.5-flash-lite  \n  • DevOps & Hosting: Vercel(웹) + Supabase(DB·Storage) + Cloudflare CDN + GitHub Actions(CI/CD)\n\n- **주요 기술 목표**  \n  ① 페이지 TTFB ≤ 150 ms, ② 게시→배포 3 초(Phase 1)/5 초(Phase 2) 이내,  \n  ③ 가용성 99.5 %(Phase 1) → 99.9 %(Phase 2), ④ AI 호출 실패율 < 1 %.\n\n- **핵심 가정**  \n  • 초기 트래픽 ≤ 10 RPS, 6 개월 내 500 RPS까지 단계적 상승.  \n  • Vercel 무료-→Pro 플랜 전환으로도 예산 범위 내.  \n  • Supabase Postgres 싱글 인스턴스로도 100 명 MAU 지원 가능(Phase 1).  \n  • AI 호출 비용은 캐싱·레이트리밋으로 월 20 USD 이하 유지.\n\n---\n\n## 2. Technology Stack Architecture\n### Frontend Technology Stack\n| 영역 | 선택 기술 & 버전 | 비고 |\n|------|-----------------|------|\n| Core Framework | Next.js 15 (React 18) | App Router+ISR |\n| State Management | React Context + zustand | 약식 글로벌 상태 |\n| Routing | Nested Route Segment (App Router) | 동적 slug 대응 |\n| UI/UX | Shadcn UI + Tailwind CSS + Radix UI | 다크모드 내장 |\n| Forms & Validation | react-hook-form + zod | 타입 안전 |\n| Build Tools | Turbopack(Next 내장) + ESLint + Prettier | CI서 Lint/GitHub Action |\n\n### Backend Technology Stack\n| 영역 | 선택 기술 | 비고 |\n|------|-----------|------|\n| Runtime | Node.js 20(LTS) | V8 기반 |\n| API Framework | tRPC (Next.js API Route) | 타입 안전 RPC |\n| API Pattern | RPC over HTTP(JSON) | 서버리스 최적 |\n| Validation | zod schema 공유 | FE/BE 동일 사용 |\n| Middleware | next-logger, rate-limit (Upstash) | 감사·보안 로그 |\n\n### Database & Persistence Layer\n| 항목 | 내용 |\n|------|------|\n| Primary DB | Supabase PostgreSQL (13+) |\n| Schema Design | Phase 1: 단일 테넌트 스키마 posts, categories, seo_scores<br>Phase 2: users, blogs, posts, categories (blog_id FK) |\n| ORM | Prisma 5 | 타입 안전, 마이그레이션 내장 |\n| Caching | Cloudflare CDN(정적)/Supabase Realtime cache(DB) |\n| Migration | prisma migrate + GitHub Action 자동 적용 |\n| Backup & Recovery | Supabase 자동 스냅샷(일 1회) + WAL 아카이브 |\n\n### Infrastructure & DevOps\n| 항목 | 내용 |\n|------|------|\n| Hosting | Vercel(Next.js) + Supabase(Managed Postgres & Storage) |\n| Containerization | 불필요(서버리스). CI용 Dockerfile만 제공 |\n| CI/CD | GitHub Actions → Vercel Preview/Prod • Prisma Migrate • Lighthouse CI |\n| Monitoring | Vercel Analytics + Supabase Studio + Sentry(Error) |\n| Logging | next-logger + Supabase Logs + Sentry Tracing |\n\n---\n\n## 3. System Architecture Design\n\n### Code Organization & Convention\n- **도메인 기준 레이어링**: `blog` / `ai` / `user` / `admin` Bounded Context.\n- **Layer-Based**:  \n  Presentation(Next Page/React) → Application(tRPC Router) → Domain(Services, Entities) → Infrastructure(Prisma, API clients).\n- **공유 모듈**: `@/lib/{ui,utils,types}` 전역 재사용.\n\n### Universal File & Folder Structure\n```\ndom-vlog/\n├── apps/\n│   └── web/                # Next.js 15\n│       ├── src/\n│       │   ├── app/        # App Router routes\n│       │   ├── components/\n│       │   ├── features/\n│       │   │   ├── ai/\n│       │   │   ├── blog/\n│       │   │   ├── seo/\n│       │   │   └── user/\n│       │   ├── lib/\n│       │   │   ├── trpc/\n│       │   │   ├── prisma/\n│       │   │   └── ai/\n│       │   └── styles/\n│       └── package.json\n├── prisma/\n│   ├── schema.prisma\n│   └── migrations/\n├── .github/\n│   └── workflows/\n├── docs/\n└── turbo.json\n```\n\n### High-Level System Architecture\n- **패턴**: 모놀리식 코드베이스(Next.js Full-stack) + 모듈러 도메인.  \n- **컴포넌트**:  \n  Client(Next.js) ←→ tRPC API (Node.js) ←→ Prisma ←→ Supabase DB  \n  AI Service(Gemini) · SEO API(Ahrefs) · Lighthouse CI는 API 레이어에서 호출.  \n- **스케일링**: Vercel 서버리스 함수 수평 확장; Supabase 읽기 Replica 추가(Phase 2).  \n- **로드밸런싱**: Vercel 글로벌 Edge Network.  \n- **Fault Tolerance**: Retry/backoff, Circuit-Breaker(axios-retry).\n\n### Data Flow & Communication Patterns\n1. 글 작성 → `POST /trpc/post.save` → DB 저장.\n2. 저장 후 Webhook → AI 파이프라인(코드블록 포맷·SEO 분석) → 결과를 `post_ai_enhanced` 테이블에 기록.\n3. 페이지 조회 시 ISR(Incremental Static Regeneration) + CDN 캐시.\n4. 멀티사용자(Phase 2): JWT(Clerk) ↔ tRPC Context → Row Level Security in Supabase.\n\n---\n\n## 4. Performance & Optimization Strategy\n- ISR + Cloudflare CDN으로 정적 페이지 Global Edge 캐싱.\n- tRPC 요청에 HTTP/2 Keep-Alive 적용, 응답 gzip-br 압축.\n- AI 응답 캐싱(Redis@Upstash) : 동일 본문 해시 24 h 캐시로 비용 절감.\n- Prisma connection pooling(Supabase pgbouncer)로 DB 연결 최적화.\n\n---\n\n## 5. Development Standards & Practices\n- **코딩 규칙**: Airbnb TypeScript Style + Prettier 자동포맷, Husky pre-commit.\n- **코드리뷰**: PR → 2 인 승인, ESLint/TSC/Lighthouse CI 통과 후 머지.\n- **테스트**: Vitest(Unit) + Playwright(E2E) + Prisma Test DB(Shadow).  \n- **문서화**: Storybook(컴포넌트) + tRPC OpenAPI plugin → Swagger UI.  \n- **에러 처리**: tRPC errorFormatter + Sentry + 유저 친화 Toast.\n\n---\n\n## 6. Implementation Roadmap & Milestones\n### Phase 1: Foundation (M0–M3)\n| 월 | 산출물 |\n|----|---------|\n| M0 | Monorepo 셋업, 기본 글 CRUD, Supabase DB 스키마 |\n| M1 | AI 스타일링 파이프라인, Vercel AI SDK 통합, 80점 가독성 달성 |\n| M2 | SEO 모듈(Ahrefs API) + 카테고리 추천, Lighthouse CI 배치 |\n| M3 | 개인 블로그 MVP 배포, 성능 지표 검증 |\n\n### Phase 2: Feature Enhancement (M4–M7)\n| 월 | 산출물 |\n|----|---------|\n| M4 | 멀티 사용자 Auth(Clerk), 테넌시 DB 마이그레이션 |\n| M5 | 사용자 대시보드(트래픽·SEO 시각화), 테마 커스터마이징 |\n| M6 | 관리자 패널, 수익화 모듈(AdSense) |\n| M7 | 99.9 % 가용성 목표, 읽기 Replica + Upstash Redis 캐시 |\n\n### Phase 3: Scaling & Optimization (M8+)\n| 월 | 산출물 |\n|----|---------|\n| M8 | 모바일 앱(React Native Expo) 프리뷰, Edge Cache 최적화 |\n| M9 | 플러그인 마켓, 협업 기능, 글로벌 다국어 지원 |\n| M10 | 규제 대응(GDPR), 감사 로그, 엔터프라이즈 플랜 |\n\n---\n\n## 7. Risk Assessment & Mitigation Strategies\n### Technical Risks\n| 위험 | 영향 | 완화책 |\n|------|------|--------|\n| AI 출력 부정확 | UX 저하 | 유저 피드백 루프 + 수동 편집 옵션 |\n| Supabase 단일 노드 장애 | 가용성 하락 | 일일 백업 + 읽기 Replica, Region Failover 계획 |\n| API 비용 급증 | OPEX 상승 | 캐싱·Rate-Limit·Batch 호출 |\n\n### Project Delivery Risks\n| 위험 | 영향 | 대응 |\n|------|------|------|\n| 일정 지연 | 마일스톤 미달 | Kanban + 주간 버퍼 10 % |\n| 인력 부족 | 품질 저하 | 모듈별 외주 대비, 우선순위 재조정 |\n| 배포 장애 | 서비스 다운 | Blue-Green 배포, 롤백 스크립트 |\n\n---\n```",
      "writedAt": "2025-06-23T16:25:10.420Z"
    },
    {
      "type": "guideline",
      "content": "# Dom Vlog Code Guideline\n\n---\n\n## 1. Project Overview\n\nDom Vlog is a full-stack, AI-powered technical blogging platform built for developers, with a phased transition from single-user MVP to a scalable, multi-tenant SaaS. The architecture leverages Next.js 15 (App Router), tRPC, Supabase (PostgreSQL), Prisma, Vercel AI SDK, and a monorepo structure. Key architectural decisions include:\n\n- **Domain-layered modularity**: Features grouped by context (`ai`, `blog`, `user`, `admin`)\n- **Monorepo with clear boundaries**: Shared code in `@/lib`, isolated features in `features/`\n- **Type safety everywhere**: TypeScript, zod, Prisma\n- **Serverless-first**: Vercel Edge, Supabase managed DB\n- **Automated CI/CD, testing, and code quality gates**\n\n---\n\n## 2. Core Principles\n\n1. **Single Responsibility**: Each file, function, and component MUST serve one clear purpose.\n2. **Type Safety**: All code MUST be fully type-annotated and pass TypeScript strict mode.\n3. **Explicit Data Flow**: Data transformations and side effects MUST be explicit and predictable.\n4. **Test-Driven**: Every feature MUST be developed with tests first (TDD).\n5. **Security by Default**: All inputs/outputs MUST be validated and sanitized at boundaries.\n\n---\n\n## 3. Language-Specific Guidelines\n\n### 3.1 TypeScript / Next.js (Frontend & API)\n\n#### File Organization\n\n- **MUST** follow the structure:\n  ```\n  apps/web/src/\n    app/           # Next.js App Router routes\n    components/    # Generic, reusable UI components\n    features/      # Domain modules: ai/, blog/, seo/, user/\n    lib/           # Shared utilities: trpc/, prisma/, ai/, types/\n    styles/        # Tailwind/global styles\n  ```\n- **MUST** colocate feature logic (UI, hooks, API calls) within `features/{domain}/`.\n\n#### Import & Dependency Management\n\n- **MUST** use absolute imports via `@/` alias.\n- **MUST** import only what is needed (no unused imports).\n- **MUST** avoid circular dependencies; refactor shared logic into `lib/` if needed.\n\n#### Error Handling\n\n- **MUST** handle all async errors via `try/catch` and surface user-friendly messages.\n- **MUST** log errors via `next-logger` or Sentry in production.\n- **MUST** use tRPC errorFormatter for API error shaping.\n\n```typescript\n// MUST: Graceful async error handling in API route\nimport { TRPCError } from '@trpc/server';\n\nexport const createPost = t.procedure.input(zodSchema).mutation(async ({ input }) => {\n  try {\n    const post = await prisma.post.create({ data: input });\n    return post;\n  } catch (err) {\n    throw new TRPCError({\n      code: 'INTERNAL_SERVER_ERROR',\n      message: 'Failed to create post',\n      cause: err,\n    });\n  }\n});\n```\n\n```typescript\n// MUST NOT: Unhandled async errors\nexport const createPost = t.procedure.input(zodSchema).mutation(async ({ input }) => {\n  const post = await prisma.post.create({ data: input }); // No error handling!\n  return post;\n});\n```\n\n### 3.2 Prisma (ORM)\n\n- **MUST** define schema in `/prisma/schema.prisma` and use migrations.\n- **MUST** use `prisma` client via a singleton pattern.\n- **MUST** validate all user input before DB operations.\n\n```typescript\n// MUST: Prisma singleton pattern\nimport { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient };\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: ['error'],\n  });\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\n```\n\n### 3.3 Tailwind CSS & Shadcn UI\n\n- **MUST** use utility classes for layout/styling; avoid custom CSS unless necessary.\n- **MUST** use Shadcn UI components for consistency.\n- **MUST** keep styles colocated with components if custom.\n\n---\n\n## 4. Code Style Rules\n\n### 4.1 MUST Follow\n\n1. **Airbnb TypeScript Style + Prettier**: Enforced via CI, Husky pre-commit.\n2. **Strict Typing**: No `any`, always prefer specific types/interfaces.\n3. **Function Length**: Functions MUST be ≤ 40 lines; split logic if longer.\n4. **Naming**: Use descriptive, camelCase for variables/functions, PascalCase for components/types.\n5. **Validation**: All API endpoints MUST validate input/output with zod.\n6. **Test Coverage**: All business logic MUST have Vitest/Playwright coverage.\n7. **Accessibility**: All UI components MUST support keyboard navigation and proper ARIA attributes.\n\n```typescript\n// MUST: Typed, validated API handler\nexport const updateProfile = t.procedure\n  .input(z.object({ displayName: z.string().min(2) }))\n  .mutation(async ({ input }) => {\n    // ...\n  });\n```\n\n```typescript\n// MUST: Accessible button component\n<button\n  type=\"button\"\n  className=\"btn-primary\"\n  aria-label=\"Save post\"\n  onClick={handleSave}\n>\n  Save\n</button>\n```\n\n### 4.2 MUST NOT Do\n\n1. **No Mixed Concerns**: MUST NOT mix UI, business logic, and data access in a single file.\n2. **No Unused/Dead Code**: MUST NOT leave commented/unreachable code in main branches.\n3. **No Direct DB Access in UI**: All data access MUST go through tRPC or API layer.\n4. **No Hardcoded Secrets**: MUST NOT commit secrets/tokens; use environment variables.\n5. **No Implicit Any**: MUST NOT use implicit `any` types.\n6. **No Complex State in Context**: MUST NOT store business logic or large state in React Context; use zustand or local state.\n\n```typescript\n// MUST NOT: Mixing DB access in a React component\nexport function PostEditor() {\n  // BAD: Direct DB call\n  const post = prisma.post.findFirst(); // ❌\n  // ...\n}\n```\n\n```typescript\n// MUST NOT: Multiple responsibilities in one file\n// File contains UI, DB, and AI logic together -- refactor!\n```\n\n---\n\n## 5. Architecture Patterns\n\n### 5.1 Component/Module Structure\n\n- **MUST** organize code by domain feature (`features/{domain}/`).\n- **MUST** colocate UI, hooks, and logic per feature.\n- **MUST** keep each file focused (SRP).\n\n```plaintext\nfeatures/\n  blog/\n    BlogList.tsx\n    useBlogList.ts\n    blogApi.ts\n  ai/\n    AiEnhancer.ts\n    useAiEnhancer.ts\n```\n\n### 5.2 Data Flow Patterns\n\n- **MUST** use tRPC for all client-server communication.\n- **MUST** validate all data at API boundaries with zod.\n- **MUST** keep data flow unidirectional: UI → tRPC → Service → DB/AI.\n\n```typescript\n// MUST: tRPC procedure with zod validation\nexport const postRouter = t.router({\n  create: t.procedure.input(postSchema).mutation( /* ... */ ),\n  list: t.procedure.query( /* ... */ ),\n});\n```\n\n### 5.3 State Management\n\n- **MUST** use zustand for global state; local state for component-specific logic.\n- **MUST NOT** use React Context for complex or business-critical state.\n\n```typescript\n// MUST: zustand store for blog editor state\nimport { create } from 'zustand';\n\ntype BlogEditorState = {\n  content: string;\n  setContent: (v: string) => void;\n};\n\nexport const useBlogEditor = create<BlogEditorState>((set) => ({\n  content: '',\n  setContent: (content) => set({ content }),\n}));\n```\n\n### 5.4 API Design Standards\n\n- **MUST** use tRPC routers per domain (`aiRouter`, `blogRouter`, etc.).\n- **MUST** document all endpoints with OpenAPI plugin.\n- **MUST** return typed, predictable error objects.\n\n```typescript\n// MUST: tRPC router per domain\nexport const appRouter = t.router({\n  ai: aiRouter,\n  blog: blogRouter,\n  user: userRouter,\n});\n```\n\n---\n\n## Example Code Snippets\n\n```typescript\n// MUST: Clear separation of concerns (UI, hook, API)\n--- features/blog/BlogList.tsx ---\nimport { useBlogList } from './useBlogList';\n\nexport function BlogList() {\n  const { blogs, isLoading } = useBlogList();\n  // ...\n}\n\n--- features/blog/useBlogList.ts ---\nimport { trpc } from '@/lib/trpc';\n\nexport function useBlogList() {\n  const { data, isLoading } = trpc.blog.list.useQuery();\n  return { blogs: data, isLoading };\n}\n```\n*Explanation: UI and data-fetching logic are separated for maintainability and testability.*\n\n```typescript\n// MUST NOT: Mixing concerns in one file\nexport function BlogList() {\n  // BAD: Data fetching and UI tightly coupled\n  const [blogs, setBlogs] = useState([]);\n  useEffect(() => {\n    fetch('/api/blogs').then(res => res.json()).then(setBlogs);\n  }, []);\n  // ...\n}\n```\n*Explanation: Avoids separation, makes testing and reuse difficult.*\n\n---\n\n## Quality Criteria\n\n- **Actionable**: Each rule is prescriptive, not vague.\n- **Justified**: Rationale is provided for each MUST/MUST NOT.\n- **Consistent**: All guidelines align with the monorepo, type-safe, modular architecture.\n- **Practical**: Examples are concise and directly usable.\n\n---\n\n**This document is the authoritative coding standard for Dom Vlog. All contributors MUST comply.**",
      "writedAt": "2025-06-23T16:25:10.420Z"
    }
  ]
}
